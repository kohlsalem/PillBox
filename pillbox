 /* This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should find a copy of the GNU General Public License
    at http://www.gnu.org/licenses/>. */

/*********************************
* Flexibly Configurable Pillbox  *
*********************************/

// Vector of pills to be drawn 
// the first field defines the type to be rendered, the following fields describe the pill
//
// ["B", Length, Width, Height] - Boxlike Cavity. Exaple ["B",11  ,6  ,3.8],  //Ramipril
// ["C", Diameter, Height ]   - Cylindrical Cavity, Layed in a ZigZag patterm, Example: ["C",7.7     ,3.8], //Lercandipin

pills = [

    ["S", 2   ,3.8], //Lercandipin
    ["B", 11 ,10 ,3.8],  //Ramipril

];

size = 7; // Nr of pills

innerwallthickness = 1;   // Size of the inner wall between pills
outerwallthickness = 1.5; // Size of the outer wall between pills
coverthickness=1;         // Size of the cover

coveroffset=0.1;          // offset between box and cover, depends on printer quality :-)

chamfer = outerwallthickness*1.5; //Chamfer on the bottom to hold the cover

pillroundoverfactor=0.3;  // Values between 0=box and 0.5=halfround for roundig up the "B" Cavities

// Set to 0.01 for higher definition curves (renders slower)
$fs = 0.15;

//**************************************************************************
// There should be no need to touch anything below here
//**************************************************************************

// if an inner wall is angled in 45°, its actual size is a bit wider. this is the difference
innerwallthickness45correct = innerwallthickness-sqrt(2*innerwallthickness^2)/2;
echo("innerwallthickness45correct",innerwallthickness45correct);

//Height (Z) for a given Pill
function GetPillHeight(pill) =
           pill[0] == "B" ? pill[3] : 
           pill[0] == "C" ? pill[2] : 
           pill[0] == "S" ? pill[2] : 
           assert(false,"Unknown Pilltype",pill[0]);
//Width (y) for a given Pill           


//this shall be the actual thickness of the theoreticall inner round pill of the rhomb
function SWidthFromMax(pill)= sqrt((MaxPillWidth() + innerwallthickness45correct)^2*2);

function GetPillWidth(pill) =
           pill[0] == "B" ? pill[2] : 
           pill[0] == "C" ? pill[1] : 
//           pill[0] == "S" ? ((pill[1]+innerwallthickness45correct)>MaxPillWidth()) ? 
//                              pill[1]+innerwallthickness45correct: MaxPillWidth() : 
           // this shall be the actual thickness of the theoreticall inner round pill of the rhomb
           // which ewuals to the small size of the rhomb‚
           pill[0] == "S" ? (pill[1]<SWidthFromMax(pill))? SWidthFromMax(pill):pill[1] : 
           assert(false,"Unknown Pilltype",pill[0]);

//Length (y) for a given Pill since Round pills get layed zigzag, this is the relative distance between 2 pills, not the actual size   
function GetPillRelativeWidth(pill) = 
           pill[0] == "B" ? pill[2] : 
           //               Theoretically it would be the radius of the pill, but may be we have more space anyways                
           pill[0] == "C" ? max([pill[1]/2,max([for(p=pills)(p!=pill)?GetPillRelativeWidth(p):0])]) -innerwallthickness/2: 
                            // relative width WITH 45 degree wall correct
           pill[0] == "S" ? max([sqrt(pill[1]^2*2)/2+innerwallthickness45correct,
                                 max([for(p=pills)(p!=pill)?GetPillRelativeWidth(p):0])]): 
           assert(false,"Unknown Pilltype",pill[0]);


echo("GetPillRelativeWidth",GetPillRelativeWidth(pills[0]));
echo("GetPillWidth",GetPillWidth(pills[0]));
echo("GetPillLength",GetPillLength(pills[0]));
echo("SWidthFromMax",SWidthFromMax());
echo("MaxPillWidth",MaxPillWidth());   
echo("GetPillLength",GetPillLength(pills[0]));
                                 
 // Avoid Negative and unknown        
function PLUS(x)=(x==undef)?0:(x>0)?x:0;           
     
//Length (x) for a given Pill           
function GetPillLength(pill) = 
           pill[0] == "B" ? pill[1] :  
           pill[0] == "C" ? pill[1] + PLUS(sqrt( (pill[1]+innerwallthickness)^2 - (GetPillRelativeWidth(pill)+innerwallthickness+innerwallthickness/2)^2 )) : 
                            // shift upwards + one innercirclediameter one radius+innerwall
           pill[0] == "S" ? GetPillWidth(pill)+MaxPillWidth()+innerwallthickness://GetPillWidth(pill)+GetPillWidth(pill)/2+innerwallthickness+innerwallthickness45correct:
                                 
           assert(false,"Unknown Pilltype",pill[0]);


//Determine maximum hight of all defined pills 
function MaxPillHeight() = max([for (pill=pills) GetPillHeight(pill)]);

//tweek to handle the difference between logical and actual width of zigzaged objects properly. 
function ActuallExtraPadding() = (max([for(pill=pills) GetPillWidth(pill)]) -max([for(pill=pills)GetPillRelativeWidth(pill)]))/2;

   // for optical reasons, "ZigZaged"elements might overlap a bit, up to innerwallthinkness. This is art, not programming. it looks better and is still good. 
function WallExtraPadding() = (ActuallExtraPadding()>(outerwallthickness-innerwallthickness)) ?ActuallExtraPadding()-(outerwallthickness-innerwallthickness):0;
//echo("WallExtraPadding",WallExtraPadding());

//Determine maximum pill width of all defined pills 
function MaxPillWidth() = max([for(pill=pills)GetPillRelativeWidth(pill)]);

//return the first n elements of a vector
function FirstElements(vec,n) = n<len(vec)?[ for (i = [0:n-1])vec[i]]:vec; 

//Determine the sum all values of a vector
function sum(v,i=0) = (i < len(v)-1) ? v[i]+sum(v,i+1) : v[i];

function SumLengthRows(n=len(pills)) = sum([for (pill=FirstElements(pills,n+1)) GetPillLength(pill)]);

pillbox();

//cover is rendered closed, open it for better printability
translate([0,boxy+5,boxy+coverthickness]) { 
rotate([-90,0,0]){
  cover();
}}

// outer dimansions of the box
boxx=SumLengthRows()+(len(pills)-1)*innerwallthickness+2*outerwallthickness;
boxy=MaxPillWidth()*size+innerwallthickness*(size-1)+2*outerwallthickness+2*WallExtraPadding();
boxz=MaxPillHeight()+outerwallthickness;
    
    
// rendering of the box    
module pillbox(){
    
    // one row of Pill Cavities
   
    module RowOfSamePill( pill,Nr=size){
      if(pill[0]=="B"){  
        for(count=[0:size-1]){
           translate([0,count*(MaxPillWidth()+innerwallthickness),0])//Move to the right position in row 
           // one rectangular cavity holdinng one pill of given size
           roundedbox([pill[1], pill[2], pill[3]],min([pill[1], pill[2]])*pillroundoverfactor);
         //  cube([pill[1], pill[2], pill[3]]);
        }
      } else if(pill[0]=="C"){ 
        
        for(count=[0:size-1]){
          radius=pill[1]/2;
          if(count%2==0){
             translate([0,count*(MaxPillWidth()+innerwallthickness),0])//Move to the right position in row 
             translate([radius,radius,0]) // move the cylinder laft alligned, as a box would have been
             cylinder( h = pill[2], r=pill[1]/2 );
          }else{
          
                // as you can see, the right sidward move to be "straight line" in case an "perfect zigzag" otherwise is pure Magic :-)
                // it considers the acrual space we need (2r+wall) and the actual place we have 
              translate([PLUS(sqrt((2*radius+innerwallthickness)^2 - (MaxPillWidth()+innerwallthickness+innerwallthickness/2)^2)),0,0])
              translate([0,count*(MaxPillWidth()+innerwallthickness),0])//Move to the right position in row 
              translate([radius,radius,0]) // move the cylinder laft alligned, as a box would have been
              cylinder( h = pill[2], r=pill[1]/2 );
          }
          
        }
      } else if(pill[0]=="S"){ innerwallthickness45correct = sqrt(2*innerwallthickness^2)-innerwallthickness;
        intersection(){
          
        rhombsize=GetPillWidth(pill);
        echo("rhombsize",rhombsize); 
        echo("GetPillWidth",GetPillWidth(pill));
   translatex = MaxPillWidth()+innerwallthickness;
        echo("translatex",translatex);
        for(count=[0:size-1]){
          radius=pill[1]/2;
          
           if(count%2==0){
             translate([0,count*(MaxPillWidth()+innerwallthickness),0])//Move to the right position in row 
             //cube([rhombsize, rhombsize, pill[2]]);
             rhombbox( rhombsize, pill[2] );
          }else{
               
                // it considers the acrual space we need (2r+wall) and the actual place we have 
              translate([translatex,0,0])
              translate([0,count*(MaxPillWidth()+innerwallthickness),0])//Move to the right position in row 
           //cube([rhombsize, rhombsize, pill[2]]);
              rhombbox( rhombsize, pill[2] );
          }//if even       
   
          
        }//for
        translate([0,0,-1])cube([GetPillLength(pill),size*(MaxPillWidth()+innerwallthickness)+2*WallExtraPadding(),pill[2]+1]);  
      }//diff
      }
    }
    
  
    module ColumnsOfDifferentPills(pills){
      for(row=[0:len(pills)-1]){
            translate([
              SumLengthRows(row) - GetPillLength(pills[row]) + row*innerwallthickness, 
              // center the pill hole per row. As always, S needs some extra handling :-/ (drives me nuts)
              (MaxPillWidth()-GetPillWidth(pills[row]))/2+WallExtraPadding()+ ((pills[row][0]=="S")?innerwallthickness45correct/2:0),
              MaxPillHeight()-GetPillHeight(pills[row])
            ])  
            RowOfSamePill(pills[row]);
        }  
    }

    
    difference(){ // Body minus Holes
        
      // somehow the body needs to be tossed around abit to match the cavities  
      translate([0,boxy,0]) { rotate([90,0,0]){
        
        linear_extrude(boxy){ // extrude the box form side profile
          polygon(
              points=
            [[0,chamfer],
             [0,boxz],
             [boxx,boxz], 
             [boxx,chamfer], 
              
             [boxx-chamfer,0],
             [chamfer,0],
             [0,chamfer]]
            );
          } // extrude
        }} // translate/rotate
         translate([outerwallthickness,outerwallthickness,outerwallthickness])
        ColumnsOfDifferentPills(pills);
     }// difference
}

// rendering of the cover 
module cover(){  
     //chamferthicknesscorrection, i don not want to get the chamfered part thinned out 
     ctc = sqrt(2*coverthickness^2)-coverthickness;
    echo("CTC",ctc);
     translate([-coverthickness-coveroffset,boxy,0]) { rotate([90,0,0]){
     union(){ 
       linear_extrude(boxy){ // extrude the box form side profile 
          polygon(
              points=
            [[0,chamfer-ctc],
             [0,boxz+coveroffset+coverthickness],
             [boxx+2*coveroffset+2*coverthickness, boxz+coveroffset+coverthickness], 
             [boxx+2*coveroffset+2*coverthickness, chamfer-ctc], 
             [boxx+2*coveroffset+2*coverthickness-chamfer+ctc, 0], 
             [boxx+2*coveroffset+  coverthickness-chamfer, 0],            
             [boxx+2*coveroffset+  coverthickness, chamfer],  
             [boxx+2*coveroffset+  coverthickness, boxz+coveroffset],  
             [coverthickness, boxz+coveroffset],  
             [coverthickness, chamfer],      
             [coverthickness+chamfer, 0],   
             [chamfer-ctc, 0],           
             [0,chamfer-ctc]]
            );
         }//extrude 
        
       translate([0,-0,-coverthickness]){  
               linear_extrude(coverthickness){ // extrude the box form side profile
                  polygon(
                      points=
                    [[0,chamfer-ctc],
                     [0,boxz+coveroffset+coverthickness],
                     [boxx+2*coveroffset+2*coverthickness, boxz+coveroffset+coverthickness], 
                     [boxx+2*coveroffset+2*coverthickness, chamfer-ctc], 
                     [boxx+2*coveroffset+2*coverthickness-chamfer+ctc, 0], 
                     [boxx+2*coveroffset+  coverthickness-chamfer, 0],  
                     [boxx+2*coveroffset+  coverthickness-chamfer-(boxx-2*chamfer)/4, boxz/1.5],                 
                     [coverthickness+chamfer+(boxx-2*chamfer)/4, boxz/1.5],
                     [coverthickness+chamfer, 0],
                     [chamfer-ctc, 0],               
                     [0,chamfer-ctc]]
                    );
                  }//extrude
        }    
      }//union
          
  }}//transrotate
}

// a rhombus shaped stare box, but moved to a origin as a normal box  of same sice would be
module rhombbox(x,h){    
    newwidth=sqrt(x^2*2);
    translate([x/2,-(newwidth-x)/2,0])rotate([0,0,45])cube([x,x,h]);
    translate([x/2,x/2,-1])cylinder(h=h+1, r=x/2);
}

// Create a cube with rounded eges along z
module roundedbox(size = [1, 1, 1], radius = 0.5) {

  if(radius == 0){
     cube(size);
  } else {
      
      // basically: create a hull around 4 round corner posts
      hull(){  
          translate([radius           , radius, 0])           cylinder(h=size[2], r= radius );
          translate([size[0] - radius , radius, 0])           cylinder(h=size[2], r= radius );
          translate([radius           , size[1] - radius, 0]) cylinder(h=size[2], r= radius );
          translate([size[0] - radius , size[1] - radius, 0]) cylinder(h=size[2], r= radius );
      }
  }
}
