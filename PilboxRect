pills = [ // Vector with all pills ["Type", Length, Width, Heigth]
/*["B",5,3,3],  
["B",5,3,3],  */
["C",5,3],
["B",6,3,3]
];

size = 7; // Nr of pills

innerwallthickness = 0.5; // Size of the inner wall between pills
outerwallthickness = 0.75; // Size of the outer wall between pills
coverthickness=1;          // Size of the cover

coveroffset=0.1; // offset between box and cover, depends on printer quality :-)

chamfer = outerwallthickness*1.5; //Chamfer on the bottom to hold the cover

PillRoundoverFactor=0.3;  // Values between 0=box and 0.5=half round

// Set to 0.01 for higher definition curves (renders slower)
$fs = 0.15;


//**************************************************************************

// Calculate the Leg of a square triangle from Hypotenuses
function Hyp2Leg(hyp) = sqrt(hyp*hyp/2);

function GetPillHeight(pill) =
           pill[0] == "B" ? pill[3] : 
           pill[0] == "C" ? pill[2] : 
           echo("Unknown Pilltype",pill[0]);
           
function GetPillWidth(pill) =
           pill[0] == "B" ? pill[2] : 
           pill[0] == "C" ? pill[1] : 
           echo("Unknown Pilltype",pill[0]);

function GetPillRelativeWidth(pill) =
           pill[0] == "B" ? pill[2] : 
           pill[0] == "C" ? pill[1]/2 : 
           echo("Unknown Pilltype",pill[0]);
           
function GetPillLength(pill) = 
           pill[0] == "B" ? pill[1] : 
           pill[0] == "C" ? pill[1]+(pill[1]+innerwallthickness)*sin(60) : 
           echo("Unknown Pilltype",pill[0]);
//Determine maximum hight of all defined pills 
function MaxPillHeight() = max([for (pill=pills) GetPillHeight(pill)]);

function WallExtraPadding() = (max([for(pill=pills)GetPillWidth(pill)]) -max([for(pill=pills)GetPillRelativeWidth(pill)]))/2;

//Determine maximum pill width of all defined pills 
function MaxPillWidth() = max([for(pill=pills)GetPillRelativeWidth(pill)]);

function sumpos(a,pos,maxi, i = 0) = (i <= maxi - 1) ? a[i][pos]+ sumpos(a, pos, maxi, i+1) : a[i][pos];

//return the first n elements of a vector
function FirstElements(vec,n) = n<len(vec)?[ for (i = [0:n-1])vec[i]]:vec; 

//Determine the sum all values of a vector
function sum(v,i=0) = (i < len(v)-1) ? v[i]+sum(v,i+1) : v[i];

function SumLengthRows(n=len(pills)) = sum([for (pill=FirstElements(pills,n+1)) GetPillLength(pill)]);


echo("SumPillsWith:",SumLengthRows());      
echo("MaxPillWidth: ",MaxPillWidth());
echo("MaxPillHeight: ",MaxPillHeight());

pillbox();

//covere is rendered closed, open it for better printability
translate([0,boxy+5,boxy+coverthickness]) { 
rotate([-90,0,0]){
  cover();
}}


boxx=SumLengthRows()+(len(pills)-1)*innerwallthickness+2*outerwallthickness;
boxy=MaxPillWidth()*size+innerwallthickness*(size-1)+2*outerwallthickness+2*WallExtraPadding();
boxz=MaxPillHeight()+outerwallthickness;
    
    
    
module pillbox(){
    
    // one row of Pill Cavities
   
    module RowOfOnePill( pill,Nr=size){
      if(pill[0]=="B"){  
        for(count=[0:size-1]){
            
           translate([0,count*(MaxPillWidth()+innerwallthickness),0])
           // one rectangular cavity holdinng one pill of given size
           roundedbox([pill[1], pill[2], pill[3]]);
    
        }
      } else if(pill[0]=="C"){ 
        
        for(count=[0:size-1]){
          radius=pill[1]/2;
          if(count%2==0){
             translate([radius,radius+count*(MaxPillWidth()+innerwallthickness),0])
             cylinder( h = pill[2], r=pill[1]/2 );
          }else{
             translate([radius+(2*radius+innerwallthickness)*sin(60),radius+count*(MaxPillWidth()+innerwallthickness),0]) 
             cylinder( h = pill[2], r=pill[1]/2 );
          }
          
        }
      }
    }
    
  
    module ColumnsOfDifferentPills(pills){
      for(row=[0:len(pills)-1]){
            translate([
              SumLengthRows(row) - GetPillLength(pills[row]) + row*innerwallthickness, 
              // center the pill hole per row
              (MaxPillWidth()-GetPillWidth(pills[row]))/2+WallExtraPadding(),
              MaxPillHeight()-GetPillHeight(pills[row])
            ])  
            RowOfOnePill(pills[row]);
        }  
    }
    

    echo("Box:",boxx,boxy,boxz);
    
    difference(){ // Body minus Holes
        
      // somehow the body needs to be tossed around abit to match the cavities  
      translate([0,boxy,0]) { rotate([90,0,0]){
        
        linear_extrude(boxy){ // extrude the box form side profile
          polygon(
              points=
            [[0,chamfer],
             [0,boxz],
             [boxx,boxz], 
             [boxx,chamfer], 
              
             [boxx-chamfer,0],
             [chamfer,0],
             [0,chamfer]]
            );
          } // extrude
        }} // translate/rotate
         translate([outerwallthickness,outerwallthickness,outerwallthickness])
        ColumnsOfDifferentPills(pills);
     }// difference
}

module cover(){

     translate([-coverthickness-coveroffset,boxy,0]) { rotate([90,0,0]){
     union(){ 
       linear_extrude(boxy){ // extrude the box form side profile 
          polygon(
              points=
            [[0,chamfer],
             [0,boxz+coveroffset+coverthickness],
             [boxx+2*coveroffset+2*coverthickness, boxz+coveroffset+coverthickness], 
             [boxx+2*coveroffset+2*coverthickness, chamfer], 
             [boxx+2*coveroffset+2*coverthickness-chamfer, 0], 
             [boxx+2*coveroffset+  coverthickness-chamfer, 0],            
             [boxx+2*coveroffset+  coverthickness, chamfer],  
             [boxx+2*coveroffset+  coverthickness, boxz+coveroffset],  
             [coverthickness, boxz+coveroffset],  
             [coverthickness, chamfer],      
             [coverthickness+chamfer, 0],   
             [chamfer, 0],           
             [0,chamfer]]
            );
         }//extrude 
        
       translate([0,-0,-coverthickness]){  
               linear_extrude(coverthickness){ // extrude the box form side profile
                  polygon(
                      points=
                    [[0,chamfer],
                     [0,boxz+coveroffset+coverthickness],
                     [boxx+2*coveroffset+2*coverthickness, boxz+coveroffset+coverthickness], 
                     [boxx+2*coveroffset+2*coverthickness, chamfer], 
                     [boxx+2*coveroffset+2*coverthickness-chamfer, 0], 
                     [boxx+2*coveroffset+  coverthickness-chamfer, 0],  
                     [boxx+2*coveroffset+  coverthickness-chamfer-(boxx-2*chamfer)/4, boxz/1.5],                 
                     [coverthickness+chamfer+(boxx-2*chamfer)/4, boxz/1.5],
                     [coverthickness+chamfer, 0],
                     [chamfer, 0],               
                     [0,chamfer]]
                    );
                  }//extrude
        }    
      }//union
          
  }}//transrotate
}


// Create a cube with rounded eges along z
module roundedbox(size = [1, 1, 1], radius = 0.5) {

  if(radius == 0){
     cube(size);
  } else {
      
      // basically: create a hull around 4 round corner posts
      hull(){  
          translate([radius           , radius, 0])           cylinder(h=size[2], r= radius );
          translate([size[0] - radius , radius, 0])           cylinder(h=size[2], r= radius );
          translate([radius           , size[1] - radius, 0]) cylinder(h=size[2], r= radius );
          translate([size[0] - radius , size[1] - radius, 0]) cylinder(h=size[2], r= radius );
      }
  }
}
